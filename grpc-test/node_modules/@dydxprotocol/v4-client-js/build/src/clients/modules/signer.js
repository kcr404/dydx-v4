"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionSigner = void 0;
const encoding_1 = require("@cosmjs/encoding");
const math_1 = require("@cosmjs/math");
const proto_signing_1 = require("@cosmjs/proto-signing");
const tx_1 = require("@dydxprotocol/v4-proto/src/codegen/dydxprotocol/accountplus/tx");
const tx_2 = require("cosmjs-types/cosmos/tx/v1beta1/tx");
const any_1 = require("cosmjs-types/google/protobuf/any");
const long_1 = __importDefault(require("long"));
const protobufjs_1 = __importDefault(require("protobufjs"));
const registry_1 = require("../lib/registry");
// Required for encoding and decoding queries that are of type Long.
// Must be done once but since the individal modules should be usable
// - must be set in each module that encounters encoding/decoding Longs.
// Reference: https://github.com/protobufjs/protobuf.js/issues/921
protobufjs_1.default.util.Long = long_1.default;
protobufjs_1.default.configure();
class TransactionSigner {
    constructor(address, stargateSigningClient, offlineSigner) {
        this.address = address;
        this.stargateSigningClient = stargateSigningClient;
        this.offlineSigner = offlineSigner;
    }
    /**
     * @description Get the encoded signed transaction or the promise is rejected if
     * no fee can be set for the transaction.
     *
     * @throws UserError if the fee is undefined.
     * @returns The signed and encoded transaction.
     */
    async signTransaction(messages, transactionOptions, fee, memo = '', publicKey) {
        var _a;
        if (!fee) {
            throw new Error('Fee cannot be undefined');
        }
        const registry = (0, registry_1.generateRegistry)();
        // Encode the messages
        const encodedMessages = messages.map((msg) => registry.encodeAsAny(msg));
        // Encode the TxExtension message
        const txExtension = tx_1.TxExtension.encode({
            selectedAuthenticators: (_a = transactionOptions.authenticators) !== null && _a !== void 0 ? _a : [],
        }).finish();
        // Create the non-critical extension message
        const nonCriticalExtensionOptions = [
            any_1.Any.fromPartial({
                typeUrl: '/dydxprotocol.accountplus.TxExtension',
                value: txExtension,
            }),
        ];
        // Construct the TxBody
        const txBody = tx_2.TxBody.fromPartial({
            messages: encodedMessages,
            memo,
            extensionOptions: [],
            nonCriticalExtensionOptions,
        });
        // Encode the TxBody
        const txBodyBytes = tx_2.TxBody.encode(txBody).finish();
        if (!publicKey) {
            throw new Error('Public key cannot be undefined');
        }
        const pubkey = (0, proto_signing_1.encodePubkey)(publicKey); // Use the public key of the signer
        const gasLimit = math_1.Int53.fromString(String(fee.gas)).toNumber();
        const authInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([{ pubkey, sequence: transactionOptions.sequence }], fee.amount, gasLimit, undefined, undefined);
        // Create the SignDoc
        const signDoc = (0, proto_signing_1.makeSignDoc)(txBodyBytes, authInfoBytes, transactionOptions.chainId, transactionOptions.accountNumber);
        // Use OfflineSigner to sign the transaction
        const signerAddress = this.address;
        if ((0, proto_signing_1.isOfflineDirectSigner)(this.offlineSigner)) {
            const { signed, signature } = await this.offlineSigner.signDirect(signerAddress, signDoc);
            const txRaw = tx_2.TxRaw.fromPartial({
                bodyBytes: signed.bodyBytes,
                authInfoBytes: signed.authInfoBytes,
                signatures: [(0, encoding_1.fromBase64)(signature.signature)],
            });
            return Uint8Array.from(tx_2.TxRaw.encode(txRaw).finish());
        }
        else {
            const rawTx = await this.stargateSigningClient.sign(this.address, messages, fee, memo, {
                accountNumber: transactionOptions.accountNumber,
                sequence: transactionOptions.sequence,
                chainId: transactionOptions.chainId,
            });
            return Uint8Array.from(tx_2.TxRaw.encode(rawTx).finish());
        }
    }
}
exports.TransactionSigner = TransactionSigner;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2lnbmVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2NsaWVudHMvbW9kdWxlcy9zaWduZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0EsK0NBQThDO0FBQzlDLHVDQUFxQztBQUNyQyx5REFPK0I7QUFFL0IsdUZBQTZGO0FBQzdGLDBEQUFrRTtBQUNsRSwwREFBdUQ7QUFDdkQsZ0RBQXdCO0FBQ3hCLDREQUFrQztBQUVsQyw4Q0FBbUQ7QUFHbkQsb0VBQW9FO0FBQ3BFLHFFQUFxRTtBQUNyRSx3RUFBd0U7QUFDeEUsa0VBQWtFO0FBQ2xFLG9CQUFRLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxjQUFJLENBQUM7QUFDMUIsb0JBQVEsQ0FBQyxTQUFTLEVBQUUsQ0FBQztBQUVyQixNQUFhLGlCQUFpQjtJQUs1QixZQUNFLE9BQWUsRUFDZixxQkFBNEMsRUFDNUMsYUFBNEI7UUFFNUIsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7UUFDdkIsSUFBSSxDQUFDLHFCQUFxQixHQUFHLHFCQUFxQixDQUFDO1FBQ25ELElBQUksQ0FBQyxhQUFhLEdBQUcsYUFBYSxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxLQUFLLENBQUMsZUFBZSxDQUNuQixRQUF3QixFQUN4QixrQkFBc0MsRUFDdEMsR0FBWSxFQUNaLE9BQWUsRUFBRSxFQUNqQixTQUEyQjs7UUFFM0IsSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUNSLE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQztTQUM1QztRQUVELE1BQU0sUUFBUSxHQUFHLElBQUEsMkJBQWdCLEdBQUUsQ0FBQztRQUVwQyxzQkFBc0I7UUFDdEIsTUFBTSxlQUFlLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBRXpF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