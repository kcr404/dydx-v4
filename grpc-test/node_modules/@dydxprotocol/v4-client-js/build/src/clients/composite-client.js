"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompositeClient = void 0;
const util_1 = require("util");
const tendermint_rpc_1 = require("@cosmjs/tendermint-rpc");
const order_1 = require("@dydxprotocol/v4-proto/src/codegen/dydxprotocol/clob/order");
const ethers_1 = require("ethers");
const long_1 = __importDefault(require("long"));
const protobufjs_1 = __importDefault(require("protobufjs"));
const helpers_1 = require("../lib/helpers");
const validation_1 = require("../lib/validation");
const types_1 = require("../types");
const constants_1 = require("./constants");
const chain_helpers_1 = require("./helpers/chain-helpers");
const indexer_client_1 = require("./indexer-client");
const errors_1 = require("./lib/errors");
const registry_1 = require("./lib/registry");
const validator_client_1 = require("./validator-client");
// Required for encoding and decoding queries that are of type Long.
// Must be done once but since the individal modules should be usable
// - must be set in each module that encounters encoding/decoding Longs.
// Reference: https://github.com/protobufjs/protobuf.js/issues/921
protobufjs_1.default.util.Long = long_1.default;
protobufjs_1.default.configure();
class CompositeClient {
    static async connect(network) {
        const client = new CompositeClient(network);
        await client.initialize();
        return client;
    }
    constructor(network, apiTimeout) {
        this.gasDenom = constants_1.SelectedGasDenom.USDC;
        this.network = network;
        this._indexerClient = new indexer_client_1.IndexerClient(network.indexerConfig, apiTimeout);
    }
    async initialize() {
        this._validatorClient = await validator_client_1.ValidatorClient.connect(this.network.validatorConfig);
    }
    get indexerClient() {
        /**
         * Get the validator client
         */
        return this._indexerClient;
    }
    get validatorClient() {
        /**
         * Get the validator client
         */
        return this._validatorClient;
    }
    get selectedGasDenom() {
        if (!this._validatorClient)
            return undefined;
        return this._validatorClient.selectedGasDenom;
    }
    setSelectedGasDenom(gasDenom) {
        if (!this._validatorClient)
            throw new Error('Validator client not initialized');
        this._validatorClient.setSelectedGasDenom(gasDenom);
    }
    async populateAccountNumberCache(address) {
        if (!this._validatorClient)
            throw new Error('Validator client not initialized');
        await this._validatorClient.populateAccountNumberCache(address);
    }
    /**
     * @description Sign a list of messages with a wallet.
     * the calling function is responsible for creating the messages.
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The Signature.
     */
    async sign(wallet, messaging, zeroFee, gasPrice, memo, account) {
        return this.validatorClient.post.sign(wallet, messaging, zeroFee, gasPrice, memo, account);
    }
    /**
     * @description Send a list of messages with a wallet.
     * the calling function is responsible for creating the messages.
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The Transaction Hash.
     */
    async send(wallet, messaging, zeroFee, gasPrice, memo, broadcastMode, account, authenticators) {
        return this.validatorClient.post.send(wallet, messaging, zeroFee, gasPrice, memo, broadcastMode, account, undefined, authenticators);
    }
    /**
     * @description Send a signed transaction.
     *
     * @param signedTransaction The signed transaction to send.
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The Transaction Hash.
     */
    async sendSignedTransaction(signedTransaction) {
        return this.validatorClient.post.sendSignedTransaction(signedTransaction);
    }
    /**
     * @description Simulate a list of messages with a wallet.
     * the calling function is responsible for creating the messages.
     *
     * To send multiple messages with gas estimate:
     * 1. Client is responsible for creating the messages.
     * 2. Call simulate() to get the gas estimate.
     * 3. Call send() to send the messages.
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The gas estimate.
     */
    async simulate(wallet, messaging, gasPrice, memo, account) {
        return this.validatorClient.post.simulate(wallet, messaging, gasPrice, memo, account);
    }
    /**
     * @description Calculate the goodTilBlock value for a SHORT_TERM order
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The goodTilBlock value
     */
    async calculateGoodTilBlock(orderFlags, currentHeight, goodTilBlock) {
        if (orderFlags === types_1.OrderFlags.SHORT_TERM) {
            if (goodTilBlock !== undefined && goodTilBlock !== 0 && goodTilBlock !== null) {
                return Promise.resolve(goodTilBlock);
            }
            else {
                const height = currentHeight !== null && currentHeight !== void 0 ? currentHeight : (await this.validatorClient.get.latestBlockHeight());
                return height + constants_1.SHORT_BLOCK_FORWARD;
            }
        }
        else {
            return Promise.resolve(0);
        }
    }
    /**
     * @description Validate the goodTilBlock value for a SHORT_TERM order
     *
     * @param goodTilBlock Number of blocks from the current block height the order will
     * be valid for.
     *
     * @throws UserError if the goodTilBlock value is not valid given latest block height and
     * SHORT_BLOCK_WINDOW.
     */
    async validateGoodTilBlock(goodTilBlock) {
        const height = await this.validatorClient.get.latestBlockHeight();
        const nextValidBlockHeight = height + 1;
        const lowerBound = nextValidBlockHeight;
        const upperBound = nextValidBlockHeight + constants_1.SHORT_BLOCK_WINDOW;
        if (goodTilBlock < lowerBound || goodTilBlock > upperBound) {
            throw new errors_1.UserError(`Invalid Short-Term order GoodTilBlock.
        Should be greater-than-or-equal-to ${lowerBound} and less-than-or-equal-to ${upperBound}.
        Provided good til block: ${goodTilBlock}`);
        }
    }
    /**
     * @description Calculate the goodTilBlockTime value for a LONG_TERM order
     * the calling function is responsible for creating the messages.
     *
     * @param goodTilTimeInSeconds The goodTilTimeInSeconds of the order to place.
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The goodTilBlockTime value
     */
    calculateGoodTilBlockTime(goodTilTimeInSeconds) {
        const now = new Date();
        const millisecondsPerSecond = 1000;
        const interval = goodTilTimeInSeconds * millisecondsPerSecond;
        const future = new Date(now.valueOf() + interval);
        return Math.round(future.getTime() / 1000);
    }
    /**
     * @description Place a short term order with human readable input.
     *
     * Use human readable form of input, including price and size
     * The quantum and subticks are calculated and submitted
     *
     * @param subaccount The subaccount to place the order under
     * @param marketId The market to place the order on
     * @param side The side of the order to place
     * @param price The price of the order to place
     * @param size The size of the order to place
     * @param clientId The client id of the order to place
     * @param timeInForce The time in force of the order to place
     * @param goodTilBlock The goodTilBlock of the order to place
     * @param reduceOnly The reduceOnly of the order to place
     *
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The transaction hash.
     */
    async placeShortTermOrder(subaccount, marketId, side, price, size, clientId, goodTilBlock, timeInForce, reduceOnly, memo, permissionedKeysAccountAuth) {
        // For permissioned orders, use the permissioning account details instead of the subaccount
        // This allows placing orders on behalf of another account when using permissioned keys
        const accountForOrder = permissionedKeysAccountAuth
            ? permissionedKeysAccountAuth.accountForOrder
            : subaccount;
        const msgs = new Promise((resolve, reject) => {
            const msg = this.placeShortTermOrderMessage(accountForOrder, marketId, side, price, size, clientId, goodTilBlock, timeInForce, reduceOnly);
            msg
                .then((it) => {
                resolve([it]);
            })
                .catch((err) => {
                console.log(err);
                reject(err);
            });
        });
        const account = this.validatorClient.post.account(accountForOrder.address, undefined);
        return this.send(subaccount.wallet, () => msgs, true, undefined, memo, undefined, () => account, permissionedKeysAccountAuth === null || permissionedKeysAccountAuth === void 0 ? void 0 : permissionedKeysAccountAuth.authenticators);
    }
    /**
     * @description Place an order with human readable input.
     *
     * Only MARKET and LIMIT types are supported right now
     * Use human readable form of input, including price and size
     * The quantum and subticks are calculated and submitted
     *
     * @param subaccount The subaccount to place the order on.
     * @param marketId The market to place the order on.
     * @param type The type of order to place.
     * @param side The side of the order to place.
     * @param price The price of the order to place.
     * @param size The size of the order to place.
     * @param clientId The client id of the order to place.
     * @param timeInForce The time in force of the order to place.
     * @param goodTilTimeInSeconds The goodTilTimeInSeconds of the order to place.
     * @param execution The execution of the order to place.
     * @param postOnly The postOnly of the order to place.
     * @param reduceOnly The reduceOnly of the order to place.
     * @param triggerPrice The trigger price of conditional orders.
     * @param marketInfo optional market information for calculating quantums and subticks.
     *        This can be constructed from Indexer API. If set to null, additional round
     *        trip to Indexer API will be made.
     * @param currentHeight Current block height. This can be obtained from ValidatorClient.
     *        If set to null, additional round trip to ValidatorClient will be made.
     *
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The transaction hash.
     */
    async placeOrder(subaccount, marketId, type, side, price, size, clientId, timeInForce, goodTilTimeInSeconds, execution, postOnly, reduceOnly, triggerPrice, marketInfo, currentHeight, goodTilBlock, memo) {
        const msgs = new Promise((resolve) => {
            const msg = this.placeOrderMessage(subaccount, marketId, type, side, price, size, clientId, timeInForce, goodTilTimeInSeconds, execution, postOnly, reduceOnly, triggerPrice, marketInfo, currentHeight, goodTilBlock);
            msg
                .then((it) => resolve([it]))
                .catch((err) => {
                throw err;
            });
        });
        const orderFlags = (0, chain_helpers_1.calculateOrderFlags)(type, timeInForce);
        const account = this.validatorClient.post.account(subaccount.address, orderFlags);
        return this.send(subaccount.wallet, () => msgs, true, undefined, memo, undefined, () => account);
    }
    /**
     * @description Calculate and create the place order message
     *
     * Only MARKET and LIMIT types are supported right now
     * Use human readable form of input, including price and size
     * The quantum and subticks are calculated and submitted
     *
     * @param subaccount The subaccount to place the order under
     * @param marketId The market to place the order on
     * @param type The type of order to place
     * @param side The side of the order to place
     * @param price The price of the order to place
     * @param size The size of the order to place
     * @param clientId The client id of the order to place
     * @param timeInForce The time in force of the order to place
     * @param goodTilTimeInSeconds The goodTilTimeInSeconds of the order to place
     * @param execution The execution of the order to place
     * @param postOnly The postOnly of the order to place
     * @param reduceOnly The reduceOnly of the order to place
     *
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The message to be passed into the protocol
     */
    async placeOrderMessage(subaccount, marketId, type, side, price, 
    // trigger_price: number,   // not used for MARKET and LIMIT
    size, clientId, timeInForce, goodTilTimeInSeconds, execution, postOnly, reduceOnly, triggerPrice, marketInfo, currentHeight, goodTilBlock) {
        const orderFlags = (0, chain_helpers_1.calculateOrderFlags)(type, timeInForce);
        const result = await Promise.all([
            this.calculateGoodTilBlock(orderFlags, currentHeight, goodTilBlock),
            this.retrieveMarketInfo(marketId, marketInfo),
        ]);
        const desiredGoodTilBlock = result[0];
        const clobPairId = result[1].clobPairId;
        const atomicResolution = result[1].atomicResolution;
        const stepBaseQuantums = result[1].stepBaseQuantums;
        const quantumConversionExponent = result[1].quantumConversionExponent;
        const subticksPerTick = result[1].subticksPerTick;
        const orderSide = (0, chain_helpers_1.calculateSide)(side);
        const quantums = (0, chain_helpers_1.calculateQuantums)(size, atomicResolution, stepBaseQuantums);
        const subticks = (0, chain_helpers_1.calculateSubticks)(price, atomicResolution, quantumConversionExponent, subticksPerTick);
        const orderTimeInForce = (0, chain_helpers_1.calculateTimeInForce)(type, timeInForce, execution, postOnly);
        let goodTilBlockTime = 0;
        if (orderFlags === types_1.OrderFlags.LONG_TERM || orderFlags === types_1.OrderFlags.CONDITIONAL) {
            if (goodTilTimeInSeconds == null) {
                throw new Error('goodTilTimeInSeconds must be set for LONG_TERM or CONDITIONAL order');
            }
            else {
                goodTilBlockTime = this.calculateGoodTilBlockTime(goodTilTimeInSeconds);
            }
        }
        const clientMetadata = (0, chain_helpers_1.calculateClientMetadata)(type);
        const conditionalType = (0, chain_helpers_1.calculateConditionType)(type);
        const conditionalOrderTriggerSubticks = (0, chain_helpers_1.calculateConditionalOrderTriggerSubticks)(type, atomicResolution, quantumConversionExponent, subticksPerTick, triggerPrice);
        return this.validatorClient.post.composer.composeMsgPlaceOrder(subaccount.address, subaccount.subaccountNumber, clientId, clobPairId, orderFlags, desiredGoodTilBlock, goodTilBlockTime, orderSide, quantums, subticks, orderTimeInForce, reduceOnly !== null && reduceOnly !== void 0 ? reduceOnly : false, clientMetadata, conditionalType, conditionalOrderTriggerSubticks);
    }
    async retrieveMarketInfo(marketId, marketInfo) {
        if (marketInfo) {
            return Promise.resolve(marketInfo);
        }
        else {
            const marketsResponse = await this.indexerClient.markets.getPerpetualMarkets(marketId);
            const market = marketsResponse.markets[marketId];
            const clobPairId = market.clobPairId;
            const atomicResolution = market.atomicResolution;
            const stepBaseQuantums = market.stepBaseQuantums;
            const quantumConversionExponent = market.quantumConversionExponent;
            const subticksPerTick = market.subticksPerTick;
            return {
                clobPairId,
                atomicResolution,
                stepBaseQuantums,
                quantumConversionExponent,
                subticksPerTick,
            };
        }
    }
    /**
     * @description Calculate and create the short term place order message
     *
     * Use human readable form of input, including price and size
     * The quantum and subticks are calculated and submitted
     *
     * @param subaccount The subaccount to place the order under
     * @param marketId The market to place the order on
     * @param side The side of the order to place
     * @param price The price of the order to place
     * @param size The size of the order to place
     * @param clientId The client id of the order to place
     * @param timeInForce The time in force of the order to place
     * @param goodTilBlock The goodTilBlock of the order to place
     * @param reduceOnly The reduceOnly of the order to place
     *
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The message to be passed into the protocol
     */
    async placeShortTermOrderMessage(subaccount, marketId, side, price, size, clientId, goodTilBlock, timeInForce, reduceOnly) {
        await this.validateGoodTilBlock(goodTilBlock);
        const marketsResponse = await this.indexerClient.markets.getPerpetualMarkets(marketId);
        const market = marketsResponse.markets[marketId];
        const clobPairId = market.clobPairId;
        const atomicResolution = market.atomicResolution;
        const stepBaseQuantums = market.stepBaseQuantums;
        const quantumConversionExponent = market.quantumConversionExponent;
        const subticksPerTick = market.subticksPerTick;
        const orderSide = (0, chain_helpers_1.calculateSide)(side);
        const quantums = (0, chain_helpers_1.calculateQuantums)(size, atomicResolution, stepBaseQuantums);
        const subticks = (0, chain_helpers_1.calculateSubticks)(price, atomicResolution, quantumConversionExponent, subticksPerTick);
        const orderFlags = types_1.OrderFlags.SHORT_TERM;
        return this.validatorClient.post.composer.composeMsgPlaceOrder(subaccount.address, subaccount.subaccountNumber, clientId, clobPairId, orderFlags, goodTilBlock, 0, // Short term orders use goodTilBlock.
        orderSide, quantums, subticks, timeInForce, reduceOnly, 0, // Client metadata is 0 for short term orders.
        order_1.Order_ConditionType.CONDITION_TYPE_UNSPECIFIED, // Short term orders cannot be conditional.
        long_1.default.fromInt(0));
    }
    /**
     * @description Cancel an order with order information from web socket or REST.
     *
     * @param subaccount The subaccount to cancel the order from
     * @param clientId The client id of the order to cancel
     * @param orderFlags The order flags of the order to cancel
     * @param clobPairId The clob pair id of the order to cancel
     * @param goodTilBlock The goodTilBlock of the order to cancel
     * @param goodTilBlockTime The goodTilBlockTime of the order to cancel
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The transaction hash.
     */
    async cancelRawOrder(subaccount, clientId, orderFlags, clobPairId, goodTilBlock, goodTilBlockTime) {
        return this.validatorClient.post.cancelOrder(subaccount, clientId, orderFlags, clobPairId, goodTilBlock, goodTilBlockTime);
    }
    /**
     * @description Cancel an order with human readable input.
     *
     * @param subaccount The subaccount to cancel the order from
     * @param clientId The client id of the order to cancel
     * @param orderFlags The order flags of the order to cancel
     * @param marketId The market to cancel the order on
     * @param goodTilBlock The goodTilBlock of the order to cancel
     * @param goodTilBlockTime The goodTilBlockTime of the order to cancel
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The transaction hash.
     */
    async cancelOrder(subaccount, clientId, orderFlags, marketId, goodTilBlock, goodTilTimeInSeconds) {
        const marketsResponse = await this.indexerClient.markets.getPerpetualMarkets(marketId);
        const market = marketsResponse.markets[marketId];
        const clobPairId = market.clobPairId;
        if (!(0, validation_1.verifyOrderFlags)(orderFlags)) {
            throw new Error(`Invalid order flags: ${orderFlags}`);
        }
        let goodTilBlockTime;
        if ((0, validation_1.isStatefulOrder)(orderFlags)) {
            if (goodTilTimeInSeconds === undefined || goodTilTimeInSeconds === 0) {
                throw new Error('goodTilTimeInSeconds must be set for LONG_TERM or CONDITIONAL order');
            }
            if (goodTilBlock !== 0) {
                throw new Error('goodTilBlock should be zero since LONG_TERM or CONDITIONAL orders ' +
                    'use goodTilTimeInSeconds instead of goodTilBlock.');
            }
            goodTilBlockTime = this.calculateGoodTilBlockTime(goodTilTimeInSeconds);
        }
        else {
            if (goodTilBlock === undefined || goodTilBlock === 0) {
                throw new Error('goodTilBlock must be non-zero for SHORT_TERM orders');
            }
            if (goodTilTimeInSeconds !== undefined && goodTilTimeInSeconds !== 0) {
                throw new Error('goodTilTimeInSeconds should be zero since SHORT_TERM orders use goodTilBlock instead of goodTilTimeInSeconds.');
            }
        }
        return this.validatorClient.post.cancelOrder(subaccount, clientId, orderFlags, clobPairId, goodTilBlock, goodTilBlockTime);
    }
    /**
     * @description Batch cancel short term orders using marketId to clobPairId translation.
     *
     * @param subaccount The subaccount to cancel the order from
     * @param shortTermOrders The list of short term order batches to cancel with marketId
     * @param goodTilBlock The goodTilBlock of the order to cancel
     * @returns The transaction hash.
     */
    async batchCancelShortTermOrdersWithMarketId(subaccount, shortTermOrders, goodTilBlock, broadcastMode) {
        const orderBatches = await Promise.all(shortTermOrders.map(async ({ marketId, clobPairId, clientIds }) => ({
            clobPairId: (clobPairId !== null && clobPairId !== void 0 ? clobPairId : (await this.indexerClient.markets.getPerpetualMarkets(marketId)).markets[marketId]).clobPairId,
            clientIds,
        })));
        return this.validatorClient.post.batchCancelShortTermOrders(subaccount, orderBatches, goodTilBlock, broadcastMode);
    }
    /**
     * @description Batch cancel short term orders using clobPairId.
     *
     * @param subaccount The subaccount to cancel the order from
     * @param shortTermOrders The list of short term order batches to cancel with clobPairId
     * @param goodTilBlock The goodTilBlock of the order to cancel
     * @returns The transaction hash.
     */
    async batchCancelShortTermOrdersWithClobPairId(subaccount, shortTermOrders, goodTilBlock, broadcastMode) {
        return this.validatorClient.post.batchCancelShortTermOrders(subaccount, shortTermOrders, goodTilBlock, broadcastMode);
    }
    /**
     * @description Transfer from a subaccount to another subaccount
     *
     * @param subaccount The subaccount to transfer from
     * @param recipientAddress The recipient address
     * @param recipientSubaccountNumber The recipient subaccount number
     * @param amount The amount to transfer
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The transaction hash.
     */
    async transferToSubaccount(subaccount, recipientAddress, recipientSubaccountNumber, amount, memo, broadcastMode) {
        const msgs = new Promise((resolve) => {
            const msg = this.transferToSubaccountMessage(subaccount, recipientAddress, recipientSubaccountNumber, amount);
            resolve([msg]);
        });
        return this.send(subaccount.wallet, () => msgs, false, undefined, memo, broadcastMode !== null && broadcastMode !== void 0 ? broadcastMode : tendermint_rpc_1.Method.BroadcastTxCommit);
    }
    /**
     * @description Create message to transfer from a subaccount to another subaccount
     *
     * @param subaccount The subaccount to transfer from
     * @param recipientAddress The recipient address
     * @param recipientSubaccountNumber The recipient subaccount number
     * @param amount The amount to transfer
     *
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The message
     */
    transferToSubaccountMessage(subaccount, recipientAddress, recipientSubaccountNumber, amount) {
        const validatorClient = this._validatorClient;
        if (validatorClient === undefined) {
            throw new Error('validatorClient not set');
        }
        const quantums = (0, ethers_1.parseUnits)(amount, validatorClient.config.denoms.USDC_DECIMALS);
        if (quantums > BigInt(long_1.default.MAX_VALUE.toString())) {
            throw new Error('amount to large');
        }
        if (quantums < 0) {
            throw new Error('amount must be positive');
        }
        return this.validatorClient.post.composer.composeMsgTransfer(subaccount.address, subaccount.subaccountNumber, recipientAddress, recipientSubaccountNumber, 0, long_1.default.fromString(quantums.toString()));
    }
    /**
     * @description Deposit from wallet to subaccount
     *
     * @param subaccount The subaccount to deposit to
     * @param amount The amount to deposit
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The transaction hash.
     */
    async depositToSubaccount(subaccount, amount, memo) {
        const msgs = new Promise((resolve) => {
            const msg = this.depositToSubaccountMessage(subaccount, amount);
            resolve([msg]);
        });
        return this.validatorClient.post.send(subaccount.wallet, () => msgs, false, undefined, memo);
    }
    /**
     * @description Create message to deposit from wallet to subaccount
     *
     * @param subaccount The subaccount to deposit to
     * @param amount The amount to deposit
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The message
     */
    depositToSubaccountMessage(subaccount, amount) {
        const validatorClient = this._validatorClient;
        if (validatorClient === undefined) {
            throw new Error('validatorClient not set');
        }
        const quantums = (0, ethers_1.parseUnits)(amount, validatorClient.config.denoms.USDC_DECIMALS);
        if (quantums > BigInt(long_1.default.MAX_VALUE.toString())) {
            throw new Error('amount to large');
        }
        if (quantums < 0) {
            throw new Error('amount must be positive');
        }
        return this.validatorClient.post.composer.composeMsgDepositToSubaccount(subaccount.address, subaccount.subaccountNumber, 0, long_1.default.fromString(quantums.toString()));
    }
    /**
     * @description Withdraw from subaccount to wallet
     *
     * @param subaccount The subaccount to withdraw from
     * @param amount The amount to withdraw
     * @param recipient The recipient address, default to subaccount address
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The transaction hash
     */
    async withdrawFromSubaccount(subaccount, amount, recipient, memo) {
        const msgs = new Promise((resolve) => {
            const msg = this.withdrawFromSubaccountMessage(subaccount, amount, recipient);
            resolve([msg]);
        });
        return this.send(subaccount.wallet, () => msgs, false, undefined, memo);
    }
    /**
     * @description Create message to withdraw from subaccount to wallet
     * with human readable input.
     *
     * @param subaccount The subaccount to withdraw from
     * @param amount The amount to withdraw
     * @param recipient The recipient address
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The message
     */
    withdrawFromSubaccountMessage(subaccount, amount, recipient) {
        const validatorClient = this._validatorClient;
        if (validatorClient === undefined) {
            throw new Error('validatorClient not set');
        }
        const quantums = (0, ethers_1.parseUnits)(amount, validatorClient.config.denoms.USDC_DECIMALS);
        if (quantums > BigInt(long_1.default.MAX_VALUE.toString())) {
            throw new Error('amount to large');
        }
        if (quantums < 0) {
            throw new Error('amount must be positive');
        }
        return this.validatorClient.post.composer.composeMsgWithdrawFromSubaccount(subaccount.address, subaccount.subaccountNumber, 0, long_1.default.fromString(quantums.toString()), recipient);
    }
    /**
     * @description Create message to send chain token from subaccount to wallet
     * with human readable input.
     *
     * @param subaccount The subaccount to withdraw from
     * @param amount The amount to withdraw
     * @param recipient The recipient address
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The message
     */
    sendTokenMessage(wallet, amount, recipient) {
        var _a;
        const address = wallet.address;
        if (address === undefined) {
            throw new errors_1.UserError('wallet address is not set. Call connectWallet() first');
        }
        const { CHAINTOKEN_DENOM: chainTokenDenom, CHAINTOKEN_DECIMALS: chainTokenDecimals } = ((_a = this._validatorClient) === null || _a === void 0 ? void 0 : _a.config.denoms) || {};
        if (chainTokenDenom === undefined || chainTokenDecimals === undefined) {
            throw new Error('Chain token denom not set in validator config');
        }
        const quantums = (0, ethers_1.parseUnits)(amount, chainTokenDecimals);
        return this.validatorClient.post.composer.composeMsgSendToken(address, recipient, chainTokenDenom, quantums.toString());
    }
    async signPlaceOrder(subaccount, marketId, type, side, price, 
    // trigger_price: number,   // not used for MARKET and LIMIT
    size, clientId, timeInForce, goodTilTimeInSeconds, execution, postOnly, reduceOnly) {
        const msgs = new Promise((resolve) => {
            const msg = this.placeOrderMessage(subaccount, marketId, type, side, price, 
            // trigger_price: number,   // not used for MARKET and LIMIT
            size, clientId, timeInForce, goodTilTimeInSeconds, execution, postOnly, reduceOnly);
            msg
                .then((it) => resolve([it]))
                .catch((err) => {
                console.log(err);
            });
        });
        const signature = await this.sign(wallet, () => msgs, true);
        return Buffer.from(signature).toString('base64');
    }
    async signCancelOrder(subaccount, clientId, orderFlags, clobPairId, goodTilBlock, goodTilBlockTime) {
        const msgs = new Promise((resolve) => {
            const msg = this.validatorClient.post.composer.composeMsgCancelOrder(subaccount.address, subaccount.subaccountNumber, clientId, clobPairId, orderFlags, goodTilBlock, goodTilBlockTime);
            resolve([msg]);
        });
        const signature = await this.sign(subaccount.wallet, () => msgs, true);
        return Buffer.from(signature).toString('base64');
    }
    // vaults
    async depositToMegavault(subaccount, amountUsdc, broadcastMode) {
        return this.validatorClient.post.depositToMegavault(subaccount, (0, helpers_1.bigIntToBytes)((0, chain_helpers_1.calculateVaultQuantums)(amountUsdc)), broadcastMode);
    }
    depositToMegavaultMessage(subaccount, amountUsdc) {
        return this.validatorClient.post.depositToMegavaultMsg(subaccount.address, subaccount.subaccountNumber, (0, helpers_1.bigIntToBytes)((0, chain_helpers_1.calculateVaultQuantums)(amountUsdc)));
    }
    async withdrawFromMegavault(subaccount, shares, minAmount, broadcastMode) {
        return this.validatorClient.post.withdrawFromMegavault(subaccount, (0, helpers_1.bigIntToBytes)(BigInt(Math.floor(shares))), (0, helpers_1.bigIntToBytes)((0, chain_helpers_1.calculateVaultQuantums)(minAmount)), broadcastMode);
    }
    withdrawFromMegavaultMessage(subaccount, shares, minAmount) {
        return this.validatorClient.post.withdrawFromMegavaultMsg(subaccount.address, subaccount.subaccountNumber, (0, helpers_1.bigIntToBytes)(BigInt(Math.floor(shares))), (0, helpers_1.bigIntToBytes)((0, chain_helpers_1.calculateVaultQuantums)(minAmount)));
    }
    /**
     * @description Submit a governance proposal to add a new market.
     *
     * @param params Parameters neeeded to create a new market.
     * @param title Title of the gov proposal.
     * @param summary Summary of the gov proposal.
     * @param initialDepositAmount Initial deposit amount of the gov proposal.
     * @param proposer proposer of the gov proposal.
     *
     * @returns the transaction hash.
     */
    async submitGovAddNewMarketProposal(wallet, params, title, summary, initialDepositAmount, memo, metadata, expedited) {
        const msg = new Promise((resolve) => {
            const composer = this.validatorClient.post.composer;
            const registry = (0, registry_1.generateRegistry)();
            const msgs = [];
            const isDydxUsd = params.ticker.toLowerCase() === 'dydx-usd';
            // x/prices.MsgCreateOracleMarket
            const createOracleMarket = composer.composeMsgCreateOracleMarket(params.id, params.ticker, params.priceExponent, params.minExchanges, params.minPriceChange, params.exchangeConfigJson);
            // x/perpetuals.MsgCreatePerpetual
            const createPerpetual = composer.composeMsgCreatePerpetual(params.id, isDydxUsd ? 1000001 : params.id, params.ticker, params.atomicResolution, params.liquidityTier, params.marketType);
            // x/clob.MsgCreateClobPair
            const createClobPair = composer.composeMsgCreateClobPair(params.id, params.id, params.quantumConversionExponent, params.stepBaseQuantums, params.subticksPerTick);
            // x/clob.MsgUpdateClobPair
            const updateClobPair = composer.composeMsgUpdateClobPair(params.id, params.id, params.quantumConversionExponent, params.stepBaseQuantums, params.subticksPerTick);
            // x/delaymsg.MsgDelayMessage
            const delayMessage = composer.composeMsgDelayMessage(
            // IMPORTANT: must wrap messages in Any type to fit into delaymsg.
            composer.wrapMessageAsAny(registry, updateClobPair), params.delayBlocks);
            // The order matters.
            if (!isDydxUsd) {
                msgs.push(createOracleMarket);
            }
            msgs.push(createPerpetual);
            msgs.push(createClobPair);
            msgs.push(delayMessage);
            // x/gov.v1.MsgSubmitProposal
            const submitProposal = composer.composeMsgSubmitProposal(title, initialDepositAmount, this.validatorClient.config.denoms, // use the client denom.
            summary, 
            // IMPORTANT: must wrap messages in Any type for gov's submit proposal.
            composer.wrapMessageArrAsAny(registry, msgs), wallet.address, // proposer
            metadata, expedited);
            resolve([submitProposal]);
        });
        return this.send(wallet, () => msg, false, undefined, memo);
    }
    async createMarketPermissionless(subaccount, ticker, broadcastMode, gasAdjustment, memo) {
        return this.validatorClient.post.createMarketPermissionless(ticker, subaccount, broadcastMode, gasAdjustment, memo);
    }
    async addAuthenticator(subaccount, authenticatorType, data) {
        // Validate the provided authenticators before sending to the validator
        const authenticator = {
            type: authenticatorType,
            config: JSON.parse(new util_1.TextDecoder().decode(data)),
        };
        if (!this.validateAuthenticator(authenticator)) {
            throw new Error('Invalid authenticator, please ensure the authenticator permissions are correct');
        }
        return this.validatorClient.post.addAuthenticator(subaccount, authenticatorType, data);
    }
    async removeAuthenticator(subaccount, id) {
        return this.validatorClient.post.removeAuthenticator(subaccount, id);
    }
    async getAuthenticators(address) {
        return this.validatorClient.get.getAuthenticators(address);
    }
    validateAuthenticator(authenticator) {
        function checkAuthenticator(auth) {
            if (auth.type === constants_1.AuthenticatorType.SIGNATURE_VERIFICATION) {
                return true; // A SignatureVerification authenticator is safe.
            }
            if (!Array.isArray(auth.config)) {
                return false; // Unsafe case: a non-array config for a composite authenticator
            }
            if (auth.type === constants_1.AuthenticatorType.ANY_OF) {
                // ANY_OF is safe only if ALL sub-authenticators return true
                return auth.config.every((nestedAuth) => checkAuthenticator(nestedAuth));
            }
            if (auth.type === constants_1.AuthenticatorType.ALL_OF) {
                // ALL_OF is safe if at least one sub-authenticator returns true
                return auth.config.some((nestedAuth) => checkAuthenticator(nestedAuth));
            }
            // If it's a base-case authenticator but not SignatureVerification, it's unsafe
            return false;
        }
        // The top-level authenticator must pass validation
        if (!checkAuthenticator(authenticator)) {
            return false;
        }
        return true;
    }
}
exports.CompositeClient = CompositeClient;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcG9zaXRlLWNsaWVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jbGllbnRzL2NvbXBvc2l0ZS1jbGllbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsK0JBQW1DO0FBSW5DLDJEQUFnRDtBQU1oRCxzRkFHb0U7QUFDcEUsbUNBQW9DO0FBQ3BDLGdEQUF3QjtBQUN4Qiw0REFBa0M7QUFFbEMsNENBQStDO0FBQy9DLGtEQUFzRTtBQUN0RSxvQ0FBNkQ7QUFDN0QsMkNBV3FCO0FBQ3JCLDJEQVVpQztBQUNqQyxxREFBaUQ7QUFDakQseUNBQXlDO0FBQ3pDLDZDQUFrRDtBQUlsRCx5REFBcUQ7QUFFckQsb0VBQW9FO0FBQ3BFLHFFQUFxRTtBQUNyRSx3RUFBd0U7QUFDeEUsa0VBQWtFO0FBQ2xFLG9CQUFRLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxjQUFJLENBQUM7QUFDMUIsb0JBQVEsQ0FBQyxTQUFTLEVBQUUsQ0FBQztBQXFCckIsTUFBYSxlQUFlO0lBTTFCLE1BQU0sQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQWdCO1FBQ25DLE1BQU0sTUFBTSxHQUFHLElBQUksZUFBZSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzVDLE1BQU0sTUFBTSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQzFCLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFRCxZQUFvQixPQUFnQixFQUFFLFVBQW1CO1FBVmxELGFBQVEsR0FBcUIsNEJBQWdCLENBQUMsSUFBSSxDQUFDO1FBV3hELElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSw4QkFBYSxDQUFDLE9BQU8sQ0FBQyxhQUFhLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDN0UsQ0FBQztJQUVPLEtBQUssQ0FBQyxVQUFVO1FBQ3RCLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxNQUFNLGtDQUFlLENBQUMs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