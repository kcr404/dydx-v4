# Stats Module Documentation

## Overview

The `stats` module is responsible for tracking and aggregating protocol statistics, particularly trading volume metrics. It maintains rolling window statistics for users and the protocol as a whole, enabling features like fee tier calculations, affiliate programs, and reward distributions.

## Key Features

- **Trading Volume Tracking**: Records and aggregates trading volumes for individual users and globally
- **Rolling Window Statistics**: Maintains statistics over a configurable time window (default 30 days)
- **User Statistics**: Tracks individual user trading activity including taker/maker volumes
- **Global Aggregates**: Maintains protocol-wide trading statistics
- **Staking Amount Caching**: Optimizes staking amount queries with caching mechanism
- **Epoch-based Processing**: Integrates with the epochs module for periodic data processing

## Module Architecture

### Core Components

#### 1. Data Structures

**BlockStats**
Transient data structure that stores trade fills within a single block:

- `Fills[]`: Array of fill records with taker/maker addresses, notional amounts, and affiliate fees

**UserStats**
Aggregated statistics for individual users:

- `TakerNotional`: Total taker volume in USDC quantums
- `MakerNotional`: Total maker volume in USDC quantums
- `Affiliate_30DRevenueGeneratedQuantums`: Revenue generated for affiliates through this user's trading
- `Affiliate_30DReferredVolumeQuoteQuantums`: Volume generated by users referred by this affiliate

**GlobalStats**
Protocol-wide aggregated statistics:

- `NotionalTraded`: Total trading volume in USDC quantums

**EpochStats**
Periodic snapshots of user statistics:

- `EpochEndTime`: Timestamp when the epoch ends
- `Stats[]`: Array of user statistics for the epoch

**StatsMetadata**
Module metadata for tracking:

- `TrailingEpoch`: The oldest epoch included in statistics

**CachedStakeAmount**
Performance optimization for staking queries:

- `StakedAmount`: Cached staking amount
- `CachedAt`: Timestamp when the cache was created

#### 2. Keeper Functions

**Main Processing Functions:**

- `ProcessBlockStats()`: Aggregates block-level statistics into epoch statistics
- `ExpireOldStats()`: Removes statistics that fall outside the configured window
- `RecordFill()`: Records individual trade fills in the transient block stats

**Data Access Functions:**

- `GetUserStats()`: Retrieves statistics for a specific user
- `GetGlobalStats()`: Retrieves protocol-wide statistics
- `GetEpochStatsOrNil()`: Retrieves statistics for a specific epoch
- `GetStakedAmount()`: Gets staking amount with caching optimization

**State Management Functions:**

- `SetUserStats()`: Updates user statistics
- `SetGlobalStats()`: Updates global statistics
- `SetEpochStats()`: Updates epoch statistics

### Integration Points

#### Dependencies

- **epochs**: For epoch-based processing and time window management
- **staking**: For retrieving user staking amounts

#### Dependent Modules

- **clob**: Provides trade fill data through `RecordFill()`
- **affiliates**: Consumes user statistics for affiliate program calculations
- **feetiers**: Uses trading statistics for fee tier determination
- **rewards**: Utilizes statistics for reward calculations

## Workflow

### 1. Trade Recording

1. When trades occur in the CLOB module, `RecordFill()` is called to store fill data in transient block storage
2. Each fill includes taker/maker addresses, notional amounts, and affiliate fee information

### 2. Block Processing

1. At the end of each block, `ProcessBlockStats()` is called
2. Block-level fills are aggregated into user statistics
3. User statistics are updated with new taker/maker volumes
4. Epoch statistics are updated with current block data
5. Global statistics are incremented with new trading volume

### 3. Epoch Boundary Processing

1. At epoch boundaries, statistics are organized into epoch snapshots
2. User statistics are sorted and stored for historical tracking

### 4. Expiration Management

1. Old epochs that fall outside the configured window are identified
2. Their statistics are subtracted from user totals to maintain the rolling window
3. Expired epoch data is deleted to manage storage

### 5. Staking Optimization

1. Staking amounts are cached to avoid expensive repeated queries
2. Cache validity is checked before returning cached values
3. Cache is refreshed when expired or when first accessed

## Configuration

### Parameters

- `WindowDuration`: The duration of the rolling statistics window (default: 30 days)

### Constants

- `StakedAmountCacheDurationSeconds`: Duration for which staking amount cache is considered valid

## Query Interface

The module exposes the following gRPC queries:

### Params

Retrieves the module parameters including the window duration.

### StatsMetadata

Returns metadata about the current state including the trailing epoch.

### GlobalStats

Provides protocol-wide trading statistics.

### UserStats

Returns individual user trading statistics including taker/maker volumes and affiliate metrics.

## Use Cases

### Fee Tier Calculation

The feetiers module uses user trading statistics to determine appropriate fee tiers, providing volume-based discounts.

### Affiliate Program

The affiliates module tracks affiliate performance using the stats module's user statistics, calculating rewards based on referred user volumes.

### Reward Distribution

The rewards module uses global and user statistics to distribute protocol rewards based on participation levels.

### Governance Analytics

Protocol statistics enable governance to make informed decisions about protocol parameters and upgrades.

## Performance Considerations

### Caching Strategy

- Staking amounts are cached with timestamps to avoid repeated expensive queries
- Cache hit/miss metrics are tracked for performance monitoring

### Storage Management

- Epoch-based expiration ensures bounded storage growth
- Transient storage is used for block-level data that doesn't need persistence
- Sorted data structures optimize query performance

### Memory Efficiency

- Statistics are aggregated rather than storing individual trades
- Efficient protobuf serialization minimizes storage overhead
- Window-based approach limits the amount of historical data maintained

## Security Considerations

### Data Integrity

- All state modifications are validated through proper keeper interfaces
- Epoch-based processing ensures consistent data aggregation
- Proper error handling prevents inconsistent states

### Access Control

- Module follows Cosmos SDK patterns for keeper access control
- Query endpoints are read-only and safe for public access
- State modifications are restricted to authorized modules

## Future Enhancements

### Expanded Metrics

- Additional trading metrics beyond volume (frequency, consistency, etc.)
- Market-specific statistics for granular analytics
- Geographic or demographic breakdowns

### Real-time Analytics

- Streaming statistics for real-time dashboards
- Alerting mechanisms for significant statistical events
- Integration with external analytics platforms

### Enhanced Caching

- Multi-level caching strategies for improved performance
- Predictive caching based on usage patterns
- Distributed caching for high-availability deployments
